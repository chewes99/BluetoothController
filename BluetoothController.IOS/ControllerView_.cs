using Foundation; using System; using UIKit; using CoreGraphics;  namespace BluetoothController.IOS { 	public partial class ControllerView : UIView 	{ 		private readonly float SCREEN_WIDTH; 		private readonly float SCREEN_HEIGHT;  		private Joystick m_LeftJS; 		private Joystick m_RightJS;  		private CGRect m_CircleJSLeft; 		private CGRect m_CircleJSRight; 		private CGRect m_CircleDPLeft; 		private CGRect m_CircleDPRight;  		private bool m_Inverted = false;   		public ControllerView (IntPtr handle) : base (handle)         { 			CGRect screenSize = UIScreen.MainScreen.Bounds; 			SCREEN_WIDTH = (float)screenSize.Height; 			SCREEN_HEIGHT = (float)screenSize.Width;  			UserInteractionEnabled = true; 			MultipleTouchEnabled = true;  			InitJoysticks ();         }  		private void InitJoysticks () 		{ 			m_LeftJS = new Joystick (SCREEN_WIDTH, SCREEN_HEIGHT, true, m_Inverted); 			m_RightJS = new Joystick (SCREEN_WIDTH, SCREEN_HEIGHT, false, m_Inverted);  			m_CircleJSLeft = new CGRect (m_LeftJS.CenterX - Joystick.STICK_RADIUS, 										 m_LeftJS.CenterY - Joystick.STICK_RADIUS, 										 Joystick.STICK_RADIUS * 2, Joystick.STICK_RADIUS * 2);  			m_CircleJSRight = new CGRect (m_RightJS.CenterX - Joystick.STICK_RADIUS, 										  m_RightJS.CenterY - Joystick.STICK_RADIUS, 										  Joystick.STICK_RADIUS * 2, Joystick.STICK_RADIUS * 2);  			m_CircleDPLeft = new CGRect (m_LeftJS.CenterX - Joystick.DISPLACEMENT_RADIUS, 										 m_LeftJS.CenterY - Joystick.DISPLACEMENT_RADIUS, 										 Joystick.DISPLACEMENT_RADIUS * 2, Joystick.DISPLACEMENT_RADIUS * 2);  			m_CircleDPRight = new CGRect (m_RightJS.CenterX - Joystick.DISPLACEMENT_RADIUS, 										  m_RightJS.CenterY - Joystick.DISPLACEMENT_RADIUS, 										  Joystick.DISPLACEMENT_RADIUS * 2, Joystick.DISPLACEMENT_RADIUS * 2);  			SetNeedsDisplay (); 		}  		public override void Draw (CGRect rect) 		{ 			base.Draw (rect); 			using (var g = UIGraphics.GetCurrentContext ()) {  				//create geometry 				var path1 = new CGPath ();  				g.SetFillColor (UIColor.LightGray.CGColor); 				path1.AddEllipseInRect (m_CircleDPLeft); 				path1.AddEllipseInRect (m_CircleDPRight);  				path1.CloseSubpath (); 				g.AddPath (path1);
				g.DrawPath (CGPathDrawingMode.FillStroke);  				var path2 = new CGPath ();  				g.SetFillColor (UIColor.DarkGray.CGColor); 				path2.AddEllipseInRect (m_CircleJSLeft); 				path2.AddEllipseInRect (m_CircleJSRight);  				path2.CloseSubpath (); 				g.AddPath (path2); 				g.DrawPath (CGPathDrawingMode.FillStroke);  				g.ShowTextAtPoint (m_LeftJS.CenterX, 30, "LEFT JOYSTICK"); 			} 		}  		public override void TouchesBegan (NSSet touches, UIEvent evt) 		{ 			base.TouchesBegan (touches, evt); 			foreach (UITouch touch in touches) { 				CGPoint p = touch.LocationInView (this); 				UpdateOvals ((float)p.X, (float)p.Y); 			} 			SetNeedsDisplay (); 		}  		public override void TouchesMoved (NSSet touches, UIEvent evt) 		{ 			base.TouchesMoved (touches, evt); 			foreach (UITouch touch in touches)  			{ 				CGPoint p = touch.LocationInView (this);
				UpdateOvals ((float)p.X, (float)p.Y); 			} 			SetNeedsDisplay (); 		}  		public override void TouchesEnded (NSSet touches, UIEvent evt) 		{ 			base.TouchesEnded (touches, evt); 			foreach (UITouch touch in touches) { 				CGPoint p = touch.LocationInView (this); 				if ((float)p.X <= SCREEN_WIDTH / 2)  				{ 					UpdateOvals (m_LeftJS.CenterX, (float)p.Y); 				} 				else 				{ 					UpdateOvals (m_RightJS.CenterX, m_RightJS.CenterY); 				}  			} 			SetNeedsDisplay (); 		}  		private void UpdateOvals (float xPosition, float yPosition) 		{ 			if (xPosition <= SCREEN_WIDTH / 2)  			{
				m_LeftJS.SetPosition (xPosition, yPosition); 				if ((m_LeftJS.Abs) <= Joystick.DISPLACEMENT_RADIUS) 				{ 					m_CircleJSLeft.X = m_LeftJS.GetPosition () [0] - Joystick.STICK_RADIUS;
					m_CircleJSLeft.Y = m_LeftJS.GetPosition () [1] - Joystick.STICK_RADIUS;
				} 				else 				{ 					m_CircleJSLeft.X = (int)(Joystick.DISPLACEMENT_RADIUS * Math.Cos (m_LeftJS.Angle * Math.PI / 180)) - (int)Joystick.STICK_RADIUS + (int)m_LeftJS.CenterX;
					m_CircleJSLeft.Y = (int)(Joystick.DISPLACEMENT_RADIUS * Math.Sin (m_LeftJS.Angle * Math.PI / 180)) - (int)Joystick.STICK_RADIUS + (int)m_LeftJS.CenterY; 				}
			} 			else  			{ 				m_RightJS.SetPosition (xPosition, yPosition); 				if ((m_RightJS.Abs) <= Joystick.DISPLACEMENT_RADIUS) { 					m_CircleJSRight.X = m_RightJS.GetPosition () [0] - Joystick.STICK_RADIUS; 					m_CircleJSRight.Y = m_RightJS.GetPosition () [1] - Joystick.STICK_RADIUS; 				} else { 					m_CircleJSRight.X = (int)(Joystick.DISPLACEMENT_RADIUS * Math.Cos (m_RightJS.Angle * Math.PI / 180)) - (int)Joystick.STICK_RADIUS + (int)m_RightJS.CenterX; 					m_CircleJSRight.Y = (int)(Joystick.DISPLACEMENT_RADIUS * Math.Sin (m_RightJS.Angle * Math.PI / 180)) - (int)Joystick.STICK_RADIUS + (int)m_RightJS.CenterY; 				} 			} 		}     } }